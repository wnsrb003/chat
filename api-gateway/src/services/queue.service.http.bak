import { config } from '../config';
import { logger } from '../utils/logger';

export interface TranslationJob {
  id: string;
  text: string;
  targetLanguages: string[];
  options?: {
    expandAbbreviations?: boolean;
    filterProfanity?: boolean;
    normalizeRepeats?: boolean;
    removeEmoticons?: boolean;
    fixTypos?: boolean;
  };
  createdAt: number;
}

export interface TranslationResult {
  id: string;
  originalText: string;
  preprocessedText: string;
  translations: Record<string, string>;
  detectedLanguage: string;
  processingTime: number;
  filtered: boolean;
  filterReason?: string;
}

class QueueService {
  private workerUrl: string;

  constructor() {
    // Python HTTP Worker URL
    this.workerUrl = process.env.PYTHON_WORKER_URL || 'http://localhost:8001';
    logger.info(`Python Worker URL: ${this.workerUrl}`);
  }

  async addJob(data: TranslationJob): Promise<{ id: string }> {
    logger.info({ jobId: data.id, text: data.text }, 'Sending job to Python worker');
    return { id: data.id };
  }

  async waitForResult(jobId: string, timeout: number = config.queue.timeout): Promise<TranslationResult> {
    // 이 메서드는 직접 호출하지 않고 processTranslation을 사용
    throw new Error('Use processTranslation instead');
  }

  async processTranslation(data: TranslationJob): Promise<TranslationResult> {
    try {
      const response = await fetch(`${this.workerUrl}/translate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          id: data.id,
          text: data.text,
          targetLanguages: data.targetLanguages,
          options: data.options,
        }),
        signal: AbortSignal.timeout(config.queue.timeout),
      });

      if (!response.ok) {
        throw new Error(`Worker returned ${response.status}: ${response.statusText}`);
      }

      const result = await response.json() as TranslationResult;
      logger.info({ jobId: data.id, processingTime: result.processingTime }, 'Translation completed');

      return result;
    } catch (error: any) {
      logger.error({ error: error.message, jobId: data.id }, 'Translation failed');
      throw error;
    }
  }

  async getQueueStats() {
    try {
      const response = await fetch(`${this.workerUrl}/health`);
      if (response.ok) {
        return {
          waiting: 0,
          active: 0,
          completed: 0,
          failed: 0,
          delayed: 0,
          total: 0,
          workerStatus: 'healthy',
        };
      }
    } catch (error) {
      // Worker offline
    }

    return {
      waiting: 0,
      active: 0,
      completed: 0,
      failed: 0,
      delayed: 0,
      total: 0,
      workerStatus: 'offline',
    };
  }

  async close() {
    logger.info('Queue service closed');
  }
}

export const queueService = new QueueService();
